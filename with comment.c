#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#define S 100

int main(int argc, char *argv[]) {
    if (argc != 3) { // если количество аргументов командной строки не равно 3
        char *errMsg = strerror(errno); // строка, содержащая сообщение об ошибке
        printf("Error occurred: the number of variables should be strongly 2 - file_name and N (%s)\n", errMsg); // вывод сообщения об ошибке на экран
        return -1; // возврат -1, чтобы программа закончилась с ошибкой
    }
    // ЧТЕНИЕ ФАЙЛА
    FILE *file;
    char arr[S]; // буфер для хранения содержимого файла
    char *ptr = arr; // указатель на начало буфера
    file = fopen(argv[1], "r"); // открытие файла для чтения
    if (file == NULL) { // если произошла ошибка при открытии файла
        char *errMsg = strerror(errno); // строка, содержащая сообщение об ошибке
        printf("Error occurred: %s\n", errMsg); // вывод сообщения об ошибке на экран
        return -1; // возврат -1, чтобы программа закончилась с ошибкой
    }
    fgets(arr, S, file); // чтение содержимого файла в буфер
    fclose(file); // закрытие файла

    if (strlen(arr) < 2) { // если длина содержимого файла меньше 2 символов
        char *errMsg = strerror(errno); // строка, содержащая сообщение об ошибке
        printf("Error occurred: the number of symbols is less than 2 in the file (%s)\n", errMsg); // вывод сообщения об ошибке на экран
        return -1; // возврат -1, чтобы программа закончилась с ошибкой
    } else printf("File consists: %s\n", arr); // иначе вывод содержимого файла на экран


    int N = atoi(argv[2]); // конвертирование второго аргумента командной строки в целое число
    int M = strlen(arr); // вычисление длины содержимого файла
    if (N > M / 2) { // если количество дочерних процессов больше, чем половина длины файла
        N = M / 2; // установка количества дочерних процессов в половину длины файла
        printf("Warning: children processes have been reduced to %d\n", N); // вывод предупреждения на экран
    }
    // СОЗДАНИЕ N ФАЙЛОВ
    char c = 'a'; // символ для формирования имени файла
    char filename[5]; // массив для хранения имени файла
    char slice[M]; // буфер для хранения части содержимого файла
    int len; // длина части содержимого файла
    for (size_t i = 0; i < N; i++) { // цикл по количеству файлов, которые нужно создать
        slice[0] = 0; // обнуление слайса (часть файла)
        if (i == N - 1 & M % N != 0) { // если это последний файл и M не делится нацело на N
            len = M - (N - 1) * (M / N); // вычисление длины последней части файла
            strncat(slice, ptr, len); // добавление последней части в слайс
        } else { // если это не последний файл
            len = M / N; // вычисление длины части файла
            strncat(slice, ptr, len); // добавление части файла в слайс
            ptr = ptr + len; // сдвиг указателя на следующую часть файла
        }

        filename[0] = c; // задание имени файла, первый символ - латинская буква в алфавитном порядке
        strcat(filename, ".txt"); // добавление расширения к имени файла
        FILE *nfile = fopen(filename, "w+"); // открытие файла на запись
        filename[1] = '\0'; // удаление первого символа из имени файла
        c++; // увеличение латинской буквы в имени файла на следующую

        // ЗАПИСЬ N ФАЙЛОВ
        fwrite(slice, sizeof(char), len, nfile); // запись слайса в файл
        slice[1] = '\0'; // удаление первого символа из слайса
        fclose(nfile); // закрытие файла
    }

    char chc = 'a'; // задание начальной латинской буквы имени файла
    char chfname[5]; // объявление имени файла
    u_long pid_arr[N]; // объявление массива идентификаторов процессов
    HANDLE proc_arr[N]; // объявление массива процессов
    HANDLE thread_arr[N]; // объявление массива потоков
    for (int i = 0; i < N; i++) { // цикл по количеству процессов
        PROCESS_INFORMATION pi; // структура для информации о процессе
        STARTUPINFO si; // структура для информации о запуске процесса
        GetStartupInfo(&si); // заполнение структуры si
        chfname[0] = chc; // задание имени файла
        strcat(chfname, ".txt "); // добавление расширения к имени файла
        char source[100] = "subproc.exe "; // объявление командной строки для запуска подпроцесса
        strcat(source, chfname); // добавление имени файла к командной строке

        BOOL res = CreateProcess(
